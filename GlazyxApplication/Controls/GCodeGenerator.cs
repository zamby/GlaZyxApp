using Avalonia;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace GlazyxApplication
{
    public class GCodeGenerator
    {
        public class GCodeSettings
        {
            public double FeedRate { get; set; } = 1000.0; // mm/min
            public double PlungeRate { get; set; } = 300.0; // mm/min
            public double LaserPower { get; set; } = 100.0; // % (0-100)
            public double SafeHeight { get; set; } = 5.0; // mm
            public double CutDepth { get; set; } = -1.0; // mm (negative for cutting)
            public double ScaleFactor { get; set; } = 0.1; // Pixel to mm conversion
            public bool LaserMode { get; set; } = true; // true = laser, false = milling
            public string Units { get; set; } = "mm"; // mm or inch
        }

        private readonly GCodeSettings _settings;
        private readonly StringBuilder _gcode;
        private readonly CultureInfo _culture = CultureInfo.InvariantCulture;

        public GCodeGenerator(GCodeSettings? settings = null)
        {
            _settings = settings ?? new GCodeSettings();
            _gcode = new StringBuilder();
        }

        public string GenerateGCode(IEnumerable<DrawObj> drawObjects)
        {
            _gcode.Clear();
            
            // Header G-Code 1.1
            WriteHeader();
            
            // Process each object
            foreach (var obj in drawObjects)
            {
                ProcessDrawObject(obj);
            }
            
            // Footer
            WriteFooter();
            
            return _gcode.ToString();
        }

        private void WriteHeader()
        {
            _gcode.AppendLine("; Generated by GlazyxApplication");
            _gcode.AppendLine($"; Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            _gcode.AppendLine("; G-Code version 1.1");
            _gcode.AppendLine();
            
            // Initialize
            _gcode.AppendLine("G90 ; Absolute positioning");
            _gcode.AppendLine($"G21 ; Set units to {_settings.Units}");
            _gcode.AppendLine("G17 ; XY plane selection");
            
            if (_settings.LaserMode)
            {
                _gcode.AppendLine("M3 ; Spindle on (laser mode)");
                _gcode.AppendLine("S0 ; Laser off initially");
            }
            else
            {
                _gcode.AppendLine("M3 S1000 ; Spindle on");
                _gcode.AppendLine($"G0 Z{_settings.SafeHeight.ToString(_culture)} ; Move to safe height");
            }
            
            _gcode.AppendLine($"F{_settings.FeedRate.ToString(_culture)} ; Set feed rate");
            _gcode.AppendLine();
        }

        private void WriteFooter()
        {
            _gcode.AppendLine();
            _gcode.AppendLine("; End of program");
            
            if (_settings.LaserMode)
            {
                _gcode.AppendLine("S0 ; Laser off");
                _gcode.AppendLine("M5 ; Spindle off");
            }
            else
            {
                _gcode.AppendLine($"G0 Z{_settings.SafeHeight.ToString(_culture)} ; Move to safe height");
                _gcode.AppendLine("M5 ; Spindle off");
            }
            
            _gcode.AppendLine("G0 X0 Y0 ; Return to origin");
            _gcode.AppendLine("M30 ; Program end");
        }

        private void ProcessDrawObject(DrawObj obj)
        {
            _gcode.AppendLine($"; Processing {obj.GetType().Name}: {obj.Name}");
            
            switch (obj)
            {
                case Circle circle:
                    ProcessCircle(circle);
                    break;
                case Rectangle rectangle:
                    ProcessRectangle(rectangle);
                    break;
                case Star star:
                    ProcessStar(star);
                    break;
                case Svg svg:
                    ProcessSvg(svg);
                    break;
                default:
                    _gcode.AppendLine($"; Unsupported object type: {obj.GetType().Name}");
                    break;
            }
            
            _gcode.AppendLine();
        }

        private void ProcessCircle(Circle circle)
        {
            var centerX = (circle.Position.X + circle.Radius) * _settings.ScaleFactor;
            var centerY = (circle.Position.Y + circle.Radius) * _settings.ScaleFactor;
            var radius = circle.Radius * _settings.ScaleFactor;
            
            // Move to start position (right of center)
            var startX = centerX + radius;
            var startY = centerY;
            
            MoveTo(startX, startY);
            StartCutting();
            
            // Full circle using G02 (clockwise)
            _gcode.AppendLine($"G02 X{startX.ToString(_culture)} Y{startY.ToString(_culture)} " +
                            $"I{(-radius).ToString(_culture)} J0 ; Full circle");
            
            StopCutting();
        }

        private void ProcessRectangle(Rectangle rectangle)
        {
            var x = rectangle.Position.X * _settings.ScaleFactor;
            var y = rectangle.Position.Y * _settings.ScaleFactor;
            var width = rectangle.Bounds.Width * _settings.ScaleFactor;
            var height = rectangle.Bounds.Height * _settings.ScaleFactor;
            
            // Rectangle corners
            var points = new[]
            {
                new { X = x, Y = y },                    // Bottom-left
                new { X = x + width, Y = y },            // Bottom-right
                new { X = x + width, Y = y + height },   // Top-right
                new { X = x, Y = y + height },           // Top-left
                new { X = x, Y = y }                     // Close rectangle
            };
            
            // Move to start
            MoveTo(points[0].X, points[0].Y);
            StartCutting();
            
            // Cut rectangle perimeter
            for (int i = 1; i < points.Length; i++)
            {
                CutTo(points[i].X, points[i].Y);
            }
            
            StopCutting();
        }

        private void ProcessStar(Star star)
        {
            if (star.Points.Count == 0) return;
            
            // Convert points to G-code coordinates
            var firstPoint = star.Points[0];
            var startX = (firstPoint.X + star.Position.X) * _settings.ScaleFactor;
            var startY = (firstPoint.Y + star.Position.Y) * _settings.ScaleFactor;
            
            MoveTo(startX, startY);
            StartCutting();
            
            // Cut star outline
            foreach (var point in star.Points.Skip(1))
            {
                var x = (point.X + star.Position.X) * _settings.ScaleFactor;
                var y = (point.Y + star.Position.Y) * _settings.ScaleFactor;
                CutTo(x, y);
            }
            
            // Close the star
            CutTo(startX, startY);
            StopCutting();
        }

        private void ProcessSvg(Svg svg)
        {
            // Process SVG elements using reflection to access private elements
            var elementsField = typeof(Svg).GetField("elements", 
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            
            if (elementsField?.GetValue(svg) is List<Svg.SvgElement> elements)
            {
                foreach (var element in elements)
                {
                    ProcessSvgElement(element, svg.Position);
                }
            }
        }

        private void ProcessSvgElement(Svg.SvgElement element, Point offset)
        {
            if (element.Points.Count == 0) return;
            
            var firstPoint = element.Points[0];
            var startX = (firstPoint.X + offset.X) * _settings.ScaleFactor;
            var startY = (firstPoint.Y + offset.Y) * _settings.ScaleFactor;
            
            MoveTo(startX, startY);
            
            // Only cut if element has fill or stroke
            if (element.HasFill || element.HasStroke)
            {
                StartCutting();
                
                foreach (var point in element.Points.Skip(1))
                {
                    var x = (point.X + offset.X) * _settings.ScaleFactor;
                    var y = (point.Y + offset.Y) * _settings.ScaleFactor;
                    CutTo(x, y);
                }
                
                StopCutting();
            }
        }

        private void MoveTo(double x, double y)
        {
            if (_settings.LaserMode)
            {
                _gcode.AppendLine($"G0 X{x.ToString(_culture)} Y{y.ToString(_culture)} ; Rapid move");
            }
            else
            {
                _gcode.AppendLine($"G0 Z{_settings.SafeHeight.ToString(_culture)} ; Lift");
                _gcode.AppendLine($"G0 X{x.ToString(_culture)} Y{y.ToString(_culture)} ; Rapid move");
            }
        }

        private void CutTo(double x, double y)
        {
            _gcode.AppendLine($"G1 X{x.ToString(_culture)} Y{y.ToString(_culture)} ; Linear cut");
        }

        private void StartCutting()
        {
            if (_settings.LaserMode)
            {
                var laserPower = (int)(_settings.LaserPower * 10.23); // Convert % to S value (0-1023)
                _gcode.AppendLine($"S{laserPower} ; Laser on at {_settings.LaserPower}%");
            }
            else
            {
                _gcode.AppendLine($"G1 Z{_settings.CutDepth.ToString(_culture)} F{_settings.PlungeRate.ToString(_culture)} ; Plunge");
                _gcode.AppendLine($"F{_settings.FeedRate.ToString(_culture)} ; Set cut feed rate");
            }
        }

        private void StopCutting()
        {
            if (_settings.LaserMode)
            {
                _gcode.AppendLine("S0 ; Laser off");
            }
            else
            {
                _gcode.AppendLine($"G0 Z{_settings.SafeHeight.ToString(_culture)} ; Lift");
            }
        }
    }
}
